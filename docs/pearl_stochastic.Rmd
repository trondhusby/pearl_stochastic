---
title: "Voorstel voor een methode voor een stochastisch regionaal prognose"
author: Trond
date: "`r format(Sys.time(), '%d %B, %Y')`"

output:
  bookdown::pdf_document2:
    toc: FALSE
    includes:
      in_header: my_header.tex
    
bibliography: stochastic_bib.bib 
---

```{r house-keeping, echo  = F, include = F}
## title: reading data
## date: 27.03.2020
## author: trond

## set global rchunk options
knitr::opts_chunk$set(fig.path='../figs/gwr-',
                      fig.path='../figs/gwr-',
                      #fig.show='hold',
               results='asis',
               message=FALSE,
               warning=FALSE,
               echo=FALSE
               )

## for reproducibility
set.seed(123)

## house keeping
library(data.table)
library(cbsodataR)
library(ggplot2)
library(gnm)
library(knitr)
library(forecast)
library(gridExtra)
library(readxl)


## nice refs
## https://data.princeton.edu/eco572/LeeCarter

## read some functions
source('../src/handy_functions.R')

```

```{r read data, include = F, cache = T}

## read cbs data
cbs_dt <- data.table(cbs_get_toc(Language='nl'))
##cbs_get_meta('60048ned')

## municipality codes
regio_dt <- data.table(cbs_get_data('70739ned',
                                    RegioS = has_substring('GM'))
                       )[,
                         c('begin_date', 'end_date') := lapply(.SD,
                                                               function(x) {
                                                                   tmp1 <- as.character(x)
                                                                   tmp2 <- ifelse(is.na(x),
                                                                                  tmp1,
                                                                                  paste(substr(tmp1, 1, 4),
                                                                                        substr(tmp1, 5, 6),
                                                                                        substr(tmp1, 7, 8),
                                                                                        sep = '-'))
                                                                   as.IDate(tmp2)
                                                               }),
                         .SDcols = c('BegindatumSorteerveld_6' , 'EinddatumSorteerveld_7')
                         ]

## migration data
## binnen mannen: 33:43
## binnen vrouwen: 45:55
## buiten vestiging manne: 102:112
## buiten vestigin vrouwen: 114:124
## buiten vertrek manne: 170:181
## buiten vertrek vrouwen: 182:193

mig_dt <- data.table(cbs_get_data('60048ned',
                                  ##RegioS = has_substring('CR') | has_substring('NL')
                                  RegioS = has_substring('GM') | has_substring('NL')
                                  )
                     )[,
                       c(1L:2L, 34L:57L, 103L:126L, 172:195)
                       ]

## population data
pop_dt <- data.table(cbs_get_data('37713',
                                  Migratieachtergrond = "T001040",
                                  ##RegioS = has_substring('CR') | has_substring('NL')
                                  RegioS = has_substring('GM') | has_substring('NL')
                                  ))

## woning data
woon_dt <- data.table(cbs_get_data('70072ned',
                                   ##RegioS = has_substring('CR') | has_substring('NL'),
                                   RegioS = has_substring('GM') | has_substring('NL'),
                                   select = c('Perioden', 'RegioS', 'Nieuwbouwwoningen_91')
                                   )
                      )[!is.na(Nieuwbouwwoningen_91),
                        ][,
                          ':=' (
                              year = as.numeric(gsub('JJ00', '', Perioden)),
                              code = as.numeric(substr(RegioS, 3, nchar(RegioS)))
                          )
                          ]
## data wrangling

## create slightly more intelligent names (1)
new_names <- data.table(a = rep(unlist(lapply(c('binnen', 'buiten.vestiging', 'buiten.vertrek'),
                                          function(x) {
                                              paste0(x, c('_mannen', '_vrouwen'))
                                          })
                                   ), each = 12),
                        b = unlist(lapply(strsplit(names(mig_dt)[-c(1,2)], split = "_"),
                                          function(x) {
                                              if(grepl('Totaal', x[1])) {
                                                  'Totaal'
                                              } else {
                                                  x[2]
                                              }
                                          }))
                        )[,
                          new_names := paste(a, b, sep = '_')
                          ]

setnames(mig_dt, 3:ncol(mig_dt), new_names$new_names)

## create slightly more intelligent names (2)
mig_ag_groups <- unique(new_names$b)
pop_dt_ag <- data.table(names(attributes(pop_dt$Leeftijd)$labels),
                        attributes(pop_dt$Leeftijd)$labels
                        )[,
                          dict :=
                              c(mig_ag_groups[1:7], rep(mig_ag_groups[8], 2),
                                rep(mig_ag_groups[9], 2), rep(mig_ag_groups[10], 3),
                                rep(mig_ag_groups[11], 4), rep(mig_ag_groups[12], 3)
                                ) 
                          ]

setkey(pop_dt, Leeftijd)
setkey(pop_dt_ag, V2)
pop_dt[pop_dt_ag, Leeftijd_groep := i.dict]

## long (1)
mig_dt_long <- melt(mig_dt,
                    id.vars = c('RegioS', 'Perioden')
                    )[!is.na(value),
                      ][,
                        c('type', 'geslacht', 'leeftijd') := tstrsplit(as.character(variable),
                                                                       split = '_')
                        ][,
                          ':=' (code = as.numeric(substr(RegioS, 3, nchar(RegioS))),
                                year = as.numeric(substr(Perioden, 1, 4))
                                )
                          ]

## long (2)
pop_dt_long <- melt(pop_dt[,
                      .(RegioS, Perioden, leeftijd = Leeftijd_groep,
                        mannen = Mannen_2, vrouwen = Vrouwen_3)
                      ],
                    id.vars = c('RegioS', 'Perioden', 'leeftijd')
                    )[,
                      ':=' (##year = as.numeric(gsub('JJ00', '', Perioden)) - 1,
                          year = as.numeric(gsub('JJ00', '', Perioden)),
                          code = as.numeric(substr(RegioS, 3, nchar(RegioS)))
                      )
                      ][,
                        sum(value),
                        by = c('code', 'year', 'leeftijd', 'variable')
                        ]

## data on municipality recodes and existing municipality codes every year
code_changes <- data.table(read_excel('../data/Recode Municipalities - Vector.xlsm', sheet = 3))[,c(1L:7L)]
codes_year <- mig_dt_long[code != 1, unique(code), by = year]

## calculate fractions for using the recoder backwards
pop_tot <- pop_dt_long[!is.na(V1) & code != 1 & leeftijd == 'Totaal', sum(V1), by = c('year', 'code')]
pop_tot[, year := year + 1]
setkey(code_changes, jaar, oud_code)
setkey(pop_tot, year, code)
code_changes[pop_tot,
             pop := i.V1
             ][!is.na(pop),
               back_frac := pop / sum(pop),
               by = c('jaar', 'nieuw_code')
               ][,
                 change_date := as.IDate(paste(jaar, maand, dag, sep = '-'))
                 ]

## recode migration municipality
mig_dt_2016gem <- lapply(seq(1995, 2017),
                         function(x) {
                             mig_dt_long[RegioS != 'NL01  ' & year == x & type != 'buiten.vertrek',
                                         recode_vector_recursive(dat = .SD,
                                                                 var_name = 'value',
                                                                 in_year = x,
                                                                 out_year = 2016),
                                         by = c('type', 'geslacht', 'leeftijd')
                                         ]
                         })

## sum departures and internal moves
mig_dt_2016gem  <- rbindlist(mig_dt_2016gem)[,
                                             sum(value), ## sum over binnen and buiten
                                             by=c('code','year','geslacht','leeftijd')
                                             ]

## recode population municipality
pop_dt_2016gem <- lapply(seq(1995, 2018),
                         function(x) {
                             pop_dt_long[code != 1 & !is.na(V1) & year == x,
                                         recode_vector_recursive(dat = .SD,
                                                                 var_name = 'V1',
                                                                 in_year = x,
                                                                 out_year = 2016),
                                         by = c('variable', 'leeftijd')
                                         ]
                         })

## calculate population at risk
pop_dt_2016gem  <- rbindlist(pop_dt_2016gem)[,
                                             year := year - 1 ## measured on 01.01
                                             ][,
                                               risk_pop := (V1 + shift(V1))/2,
                                               by = c('code','leeftijd', 'variable')
                                               ]

## recode woon dt to 2016 municipality
woon_dt_2016gem <- lapply(seq(1995, 2017),
                          function(x) {
                              woon_dt[code != 1 & year == x,
                                    recode_vector_recursive(dat = .SD,
                                                            var_name = 'Nieuwbouwwoningen_91',
                                                            in_year = x,
                                                            out_year = 2016)
                                    ]
                         })

woon_dt_2016gem  <- rbindlist(woon_dt_2016gem)

## merge
inp_dt <- merge(pop_dt_2016gem[!is.na(risk_pop)],
                mig_dt_2016gem,
                by.x = c('code', 'year', 'leeftijd', 'variable'),
                by.y = c('code', 'year', 'leeftijd', 'geslacht'),
                all.x = T
                )[,
                  leeftijd := factor(leeftijd, levels = unique(mig_dt_long$leeftijd))
                  ][is.na(V1.y) & !is.na(risk_pop),
                    V1.y := 0
                    ]

setnames(inp_dt,
         c('variable', 'V1.x', 'V1.y'),
         c('geslacht', 'bevolking', 'verhuizingen')
         )

## add population data to housing model and calculate 3-year rolling average
inp_wn_dt <- merge(woon_dt_2016gem,
                 inp_dt[leeftijd == 'Totaal',
                        .(bevolking = sum(bevolking)),
                        by = c('code', 'year')
                        ],
                 by = c('code', 'year')
                 )[,
                   nieuwbouwwoningen_rmean :=  frollmean(Nieuwbouwwoningen_91, n = 3),
                   by = c('code')
                   ]

## ggplot(inp_wn_dt[code != 1 & !is.na(nieuwbouwwoningen_rmean)],
##        aes(year, nieuwbouwwoningen_rmean, group = code))  +
##     geom_line(aes(col = code)) +
##     theme_bw()

## calculate regional factor and normalise: (x-min(x))/(max(x)-min(x))
inp_dt[!is.na(risk_pop),
       verhuiskans := sum(verhuizingen[leeftijd != 'Totaal']) / sum(risk_pop[leeftijd != 'Totaal']),
       by = c('year', 'geslacht', 'leeftijd')
       ][,
         estimated_moves := verhuiskans * risk_pop
         ][,
           moves_sum := verhuizingen[leeftijd == 'Totaal'],
           by = c('year', 'geslacht', 'code')
           ][leeftijd != 'Totaal',
             moves_rmean := frollmean(moves_sum, n = 3, na.rm = T),
             by = c('geslacht', 'leeftijd', 'code')
             ][leeftijd != 'Totaal',
               regional_factor := moves_rmean / sum(estimated_moves, na.rm = T),
               by = c('year', 'geslacht', 'code')
               ]

## check number of municipalities
## inp_dt[,
##        verhuizingen[leeftijd == 'Totaal'],
##        by = c('year', 'geslacht', 'code')
##        ][,
##          .N,
##          by = c('year', 'geslacht')
##          ]

```


```{r estimate-models-migration, include = F, cache = T}

## set starting values for the regional factor trend
start_krf <- inp_dt[leeftijd != 'Totaal' & year > 1997,
                      mean(regional_factor),
                      by = year
                    ][,
                      log(V1 / mean(V1))
                      ]

## models for regional factor
LC.gaussian.reg <- gnm(regional_factor ~
                           as.factor(code) +
                           as.factor(geslacht) +
                           Mult(as.factor(code), as.factor(year)),
                        family = gaussian(link = 'log'),
                        start = c(rep(NA, 781), start_krf),
                        data = inp_dt[leeftijd != 'Totaal' & year > 1997,
                                     .(regional_factor = unique(regional_factor)),
                                     by = c('year', 'code', 'geslacht')
                                    ]
                        )

## find index of time-trend coefficients
tt_names <- paste0("Mult(as.factor(code), .).",
                   paste0("as.factor(year)", 1998:2017)
                   )
tt_ind_r <- match(tt_names, names(coefficients(LC.gaussian.reg)))

## estimate model used for prediction
LC.gaussian.reg.pred <- glm(regional_factor ~
                                  as.factor(code) +
                                  as.factor(geslacht) + 
                            as.factor(code)*k,
                            family=gaussian(link = 'log'),
                            data=merge(
                                inp_dt[leeftijd != 'Totaal' & year > 1997,
                                       .(regional_factor = unique(regional_factor)),
                                       by = c('year', 'code', 'geslacht')
                                       ],
                                data.table(year = seq(1998, 2017),
                                           k = as.numeric(coefficients(LC.gaussian.reg)[tt_ind_r])),
                                by = 'year'
                            )
                        )

```

```{r estimate-models-housing, include = F, cache = T}

## set starting values for the housing construction trend
start_k_w <- inp_wn_dt[!is.na(nieuwbouwwoningen_rmean),
                     mean(nieuwbouwwoningen_rmean),
                     by = year
                     ][,
                       ##log(V1 / mean(V1))
                       normalise_vec(V1)
                       ]

## estimate model
LC.poisson.h <- gnm(nieuwbouwwoningen_rmean ~
                            log(offset(bevolking)) +
                            as.factor(code)+
                            Mult(as.factor(code), as.factor(year)),
                        family=poisson(link="log"),
                        start = c(rep(NA, 781), start_k_w),
                        data= inp_wn_dt[!is.na(nieuwbouwwoningen_rmean)]
                    )

## find index of time-trend coefficients
tt_ind_h <- match(tt_names, names(coefficients(LC.poisson.h)))

LC.poisson.pred.h <- glm(nieuwbouwwoningen_rmean ~
                            log(offset(bevolking)) +
                            as.factor(code)+
                            as.factor(code)*k,
                        family=poisson(link="log"),
                        data=merge(inp_wn_dt,
                                   data.table(year = seq(1998, 2017),
                                              k = as.numeric(coefficients(LC.poisson.h)[tt_ind_h])),
                                   by = 'year')
                        )

```

```{r time-series-models, include = F, cache = T}

## simulations settings
sim_len <- 23
n_sim <- 100

## create time series object of trend variables
y_r <- ts(as.numeric(coefficients(LC.gaussian.reg)[tt_ind_r]),
          start = 1998)

y_w <- ts(as.numeric(coefficients(LC.poisson.h)[tt_ind_h]),
          start = 1998)

## estimate time series models
r_mod <- ets(y_r)
w_mod <- ets(y_w, model = 'ANN')

## simulations
sims <- lapply(seq(1, n_sim),
               function(x) {
                   data.table(reg = simulate(r_mod, nsim = sim_len),
                              woningen = simulate(w_mod, nsim = sim_len)
                              )
               })

```


```{r simulations-region, include = F, cache = T}

## temporary data frame for simulation
tmp_dt <- rbindlist(lapply(seq(1, sim_len),
                           function(x){
                               inp_dt[year == 2017 & leeftijd == 'Totaal',
                                          #-'bevolking'
                                          ][,
                                            year := 2017 + x
                                            ]
                           }))

sim_regio <- rbindlist(lapply(seq(1,n_sim),
                              function(x){
                                  k <- sims[[x]]$reg
                                  rbind(
                                      data.table(tmp_dt[geslacht == 'mannen', ],
                                                 run = x,
                                                 k = rep(as.numeric(k),
                                                         each = length(unique(tmp_dt$code)))
                                                 ),
                                      data.table(tmp_dt[geslacht == 'vrouwen', ],
                                                 run = x,
                                                 k = rep(as.numeric(k),
                                                         each = length(unique(tmp_dt$code)))
                                                 )
                                  )
                              })
                       )

## use estimated models to forecast regional moves
sim_regio[,
          regional_factor_k := exp(predict(LC.gaussian.reg.pred, newdata=.SD)),
          by = run            
          ][,
            ':=' (k_old = k, k = mean(k)),
            by = c('code', 'year', 'geslacht')
            ][,
              regional_factor_mean := exp(predict(LC.gaussian.reg.pred, newdata=.SD)),
              by = run
              ]

```

```{r simulations-housing, include = F, cache = T}

## temporary data frame for simulation
tmp_dt <- rbindlist(lapply(seq(1, sim_len),
                           function(x){
                               inp_wn_dt[year == 2017,
                                          #-'bevolking'
                                          ][,
                                            year := 2017 + x
                                            ]
                           }))

sim_woning <- rbindlist(lapply(seq(1,n_sim),
                              function(x){
                                  k_w <- sims[[x]]$woningen
                                  data.table(tmp_dt,
                                             run = x,
                                             k = rep(as.numeric(k_w),
                                                     each = length(unique(tmp_dt$code)))
                                             )
                              })
                        )

## use estimated models to forecast regional housing construction
sim_woning[,
      nieuwbouw_k := exp(predict(LC.poisson.pred.h, newdata=.SD)),
      by = run            
      ][,
        ':=' (k_old = k, k = mean(k)),
        by = c('code', 'year')
        ][,
          nieuwbouw_mean := exp(predict(LC.poisson.pred.h, newdata=.SD)),
          by = run
          ]


```



```{r simulaties-pearl, include = F}

out <- list()

gamma_w <- c(0, 1)
gamma_f <- c(0, 1)
gammas <- expand.grid(gamma_w, gamma_f)
names(gammas) <- c('gamma_w', 'gamma_f')

counter <- 1

## loop over different gammas and year
for (gm in seq(1, nrow(gammas))) {
    pop <- list()
    for (yr in seq(2018, 2017+sim_len)) {
      message(paste("Simulating population, gamma",
                    paste(gammas[gm,], collapse = ';'),
                    "Now processing year", yr)
              )
        idx <- which(seq(2018, 2017+sim_len) == yr)
        if(yr == 2018) {
            pop_init  <- inp_dt[year == 2017 & leeftijd != 'Totaal',                                .(code, leeftijd, geslacht, risk_pop, net_migration = 0, run = as.integer(n_sim), year = yr)
                                ][rep(seq(1, .N), run),
                                  ][,
                                    run := seq(1, n_sim),
                                    by = c('code', 'leeftijd', 'geslacht')
                                    ]
    } else {
        pop_init <- pop[[idx-1]]
    }
        ## verhuiskans
        verhuiskans <- inp_dt[leeftijd != 'Totaal' & year == 2017,
                              .(verhuiskans = unique(verhuiskans)),
                              by = c('leeftijd', 'geslacht')
                              ]
        ## calculate estimated moves
        estimated_moves <- merge(verhuiskans,
                                 pop_init[,-'year'],
                                 by = c('leeftijd', 'geslacht'),
                                 all.x = T,
                                 all.y = T,
                                 allow.cartesian = T
                                 )[,
                                   estimated_moves := verhuiskans * risk_pop
                                   ]
        ## calculate moves
        moves <- merge(estimated_moves,
                       sim_regio[year == yr,
                                 .(code, geslacht, run,
                                   regional_factor_k, regional_factor_mean
                                   )
                                 ],
                       by = c('code', 'geslacht', 'run')
                       )[,
                         .(code,
                           geslacht,
                           leeftijd,
                           run,
                           regional_factor = (1-gammas$gamma_f[gm])*regional_factor_mean + gammas$gamma_f[gm]*regional_factor_k,
                           estimated_moves
                           )
                         ][,
                           V1 := estimated_moves * regional_factor
                           ]
        ## calculate destination attraction
        woning <- sim_woning[year == yr,
                             .(code,
                               prob_w = nieuwbouw_k/sum(nieuwbouw_k),
                               prob_m = nieuwbouw_mean/sum(nieuwbouw_mean)
                               ),
                             by = run
                             ][,
                               prob := (1-gammas$gamma_w[gm])*prob_m + gammas$gamma_w[gm]*prob_w
                               ]
        ## migration
        migration <- merge(moves,
                           woning,
                           by = c('code', 'run')
                           )[,
                             .(code,
                               emigration = V1,
                               prob,
                               immigration = sum(V1)*prob),
                             by = c('run', 'leeftijd', 'geslacht')
                             ]
        ## update population
        pop[[idx]] <- merge(pop_init,
                            migration,
                            by = c('code', 'leeftijd', 'geslacht', 'run')
                            )[,
                              .(code,
                                leeftijd,
                                geslacht,
                                net_migration = immigration - emigration,
                                risk_pop = risk_pop + net_migration,
                                run,
                                gamma = paste('gamma_w =', gammas$gamma_w[gm], '\n',
                                              'gamma_f =', gammas$gamma_f[gm]),
                                year = yr)
                              ]       
    }
    out[[counter]] <- rbindlist(pop)
    counter <- counter + 1
}

## bind results
out <- rbindlist(out)

## ## create lower and upper 50 percent CI
## out[,
##     c('lower_50CI', 'mean_50CI','upper_50CI') :=
##         {
##             tmp = quantile(risk_pop, probs = seq(0, 1, by = 0.1))
##             list(tmp[2], tmp[6], tmp[10])
##         },
##     by = c('RegioS', 'leeftijd', 'geslacht', 'year', 'gamma_w', 'gamma_m', 'gamma_f')
##     ]

## ggplot(out[RegioS == 'CR23  ',
##            sum(risk_pop),
##            by = c('leeftijd', 'geslacht', 'run', 'year')
##            ],
##        aes(year, V1, group = run)
##        ) +
##     geom_line() +
##     facet_wrap(geslacht ~ leeftijd, scales = 'free') +
##     theme_bw()

```


# Aanleiding
De huidige methodiek gebruikt om bandbreedtes in PEARL te bepalen is quasi-stochastisch. Er zijn al eerder pogingen geweest om een volle stochastische methodiek op te stellen, deze pogingen zijn echter gestrand wegens gebrek aan tijd en computercapaciteit. Door de ervaring van de proefrun met Microsoft Azure vorig jaar hebben we geleerd dat het draaien van PEARL in de cloud goed te doen is. Daarom lijkt het nuttig om opnieuw te kijken naar de methodiek voor een beperkte stochastische run.

Een toegevoegde waarde van een volle stochastische methode tov de huidige quasistochastische methode is dat alle voorspellingsvariabelen, inclusief ratio's en andere afgeleide indices, probabilistisch consistent zijn. Voorspellingen kunnen worden gemaakt door middel van relatief eenvoudige Monte Carlo-simulaties om een verdeling van mogelijke resultaten te produceren. Het is dan noodzakelijk om voor elke demografische component de gemiddelde (of mediaan), variantie-covariantiestructuur en distributievorm te specificeren. Deze parameters kunnen worden geschat op basis van "expert judgment", door evaluatie van schattingsfouten of door een tijdsreeksmodel [@keilman2001uncertain].

Hier ontwikkelen we een methode voor probabilistische voorspellingen van vertrek en woningbouwproductie op basis van tijsdreeksmodellen. De aanpak is gebaseerd op het Lee Carter model, vaak gebruikt om leeftijdspecifieke sterfte of sterftekans te schatten [@booth2006lee]. Het Lee Carter model is inmiddels ook voor migratie toegepast [@wisniowski2015bayesian], voor zowel verhuiskansen als voor aantallen. Voor aantallen is de Poisson versie van het Lee Carter model het meest geschikte [@brouhns2002poisson]. Lee Carter modellen worden meestal gebruikt voor nationale prognoses, en voor demografische variabelen met een leeftijdsdimensie. Hier gebruiken we ze ook voor variabelen met een regio-dimensie, wat, zover ik weet, niet eerder is gedaan.

In deze notitie laat ik zien hoe we Lee Carter modellen kunnen gebruiken om de volgende PEARL-input te voorspellen: leeftijdsspecifieke nationale verhuizingen, regio-specifieke aanpassingsfactoren zoals gebruikt in PEARL en regio-specifieke aantallen nieuwbouwwoningen. Als proof of concept worden de voorgespelde variabelen gecombineerd met een versimpelde cohort-component model voor een Monte Carlo voorspelling van de toekomstige netto migratie en risikobevolking.

# Binnenlandse migratie in PEARL

In PEARL wordt het aantal vertrokken mensen uit een gemeente in meerdere stappen bepaald. Hieronder een korte omschrijving van deze stappen, gemaakt op basis van Andries' paper over PEARL.

Het aantal nationale verhuizingen en risikobevolking voor leeftijd $x$ en geslacht $g$ in jaar $t$, schrijven we als $M_{x,t}^{g}$ en $P_{x,t}^{g}$. De nationale leeftijdspecifieke verhuiskans is berekent op de volgende manier

\begin{equation}
\tag{1}
V_{x,t}^{g} = M_{x,t}^{g} / P_{x,t}^{g}
\end{equation}

Het aantal vertrokken personen uit gemeente $i$, $\hat{M}_{i,x,t}^{g}$, wordt in eerste instantie geschat als het product van de nationale verhuiskans en de risikobevolking in gemeente $i$, $P_{i,x,t}^{g}$.

\begin{equation}
\tag{2}
\hat{M}_{i,x,t}^{g} = V_{x,t}^{g} * P_{i,x,t}^{g}
\end{equation}

Dit wordt dan vervolgens gecorrigeerd met een regionaal factor $F_{i,t}^{g}$. Deze factor is berekent als

\begin{equation}
\tag{3}
F_{i,t}^{g} = \frac{\bar{M}_{i,t}^{g}}{\sum_{x} \hat{M}_{i,x,t}^{g}}
\end{equation}

waar $\bar{M}_{i,t}^{g} = (1/3) \sum_{z=1}^{3} M_{i,x,t-z}^{g}$, ofwel het gemiddelde aantal vertrokken personen de afgelopen drie jaar. Het uiteindelijke aantal vertrokken personen wordt bepaald als

\begin{equation}
\tag{4}
M_{i,x,t}^{g} = F_{i,t}^{g}*\hat{M}_{i,x,t}^{g}
\end{equation}

In PEARL is er een nauwe samenhang tussen netto nieuwbouw en vestiging in een regio, maar er zijn in het model meerdere manieren waarop nieuwbouw vestiging beinvloedt. In deze notitie maken we geen onderscheid tussen lange- en korte-afstandsverhuizingen, maar gaan er simpelweg vanuit dat een er positieve relatie bestaat tussen nieuwbouwwoningen en vestigingskans.

# Stochastisch opzet PEARL

Ik stel voor om de regionale factor, $F_{i,t}^{g}$ en het aantal nieuwbouwwoningen $W_{i,t}$ te varieren. Op deze manier kunnen we twee verschillende effecten simuleren: variantie aan de vestigingskant via $W_{i,t}$ en variantie aan de vertrekkant via $F_{i,t}^{g}$.

## Lee Carter modellen

Om te beginnen, definieren we eerst een demografisch variabel $Y_{i,t}$.

$$
\begin{aligned}
Y_{i,t} &= \begin{bmatrix}  F_{i,t}^{g} \\ W_{i,t} \end{bmatrix}
\end{aligned}
$$


In de literatuur worden Lee Carter modellen gebruikt voor leeftijd-specifieke processen, maar hier gebruiken we ze ook voor processen met een regio-dimensie. Dit betekent dat $d$ bevat zowel leeftijd $x$ als regio $i$. De processen die we met het model beschrijven zijn de regionale factor en woningbouwproductie per regio. Het Lee-Carter model wordt verder gespecificeerd als een functie van de regio-specifieke parameters $\alpha_{i}$ (level) en $\beta_{i}$ (slope) en de tijdspecifieke parameters $k_{t}$.

De regionale factor is, in alle regio's bijna gelijk voor mannen en vrouwen. Daarom schatten we een Lee Carter model voor de regionale factor, waar $\delta_{g}$ de niveauverschil tussen mannen en vrouwen aangeeft.

$$
\begin{aligned}
\log F_{i,t}^{g} &= \alpha_{i}^{F} + \delta_{g}^{F} + \beta_{i}^{F} k_{t}^{F} + \varepsilon_{i,g,t}^{F}
\end{aligned}
$$

Het Lee Carter model voor woningbouw kunnen we als volgt schrijven:

$$
\begin{aligned}
\log W_{i,t} &= \alpha_{i}^{W}   + \beta_{i}^{W} k_{t}^{W} + \varepsilon_{i,t}^{W}
\end{aligned}
$$ee


Als we zien van de vergelijkingen wordt de dynamiek in de tijsreeks volledig opgevangen door de geschatte pure tijdstrend $k_{t}$. $k_{t}$ is een vector met de volgende 2 elementen

$$
\begin{aligned}
k_{t} &= \begin{bmatrix}  f_{t} \\ w_{t} \end{bmatrix}
\end{aligned}
$$


Hoe zit dit allemaal in elkaar? Een klein voorbeeld met een een-stap-vooruit voorspelling is wellicht handig. Eerst worden de Lee Carter modellen geschat, waardoor we schattingen van $\hat{\alpha}_{d}$ en $\hat{\beta}_{d}$ en de pure tijdstrend $\hat{k}_{t}$ krijgen. Vervolgens maken we een een-stap-vooruit voorspelling van $\hat{k}_{t+1}$ en we kunnen de regio-specifieke $Y_{i,t+1}$ berekenen met de geschatte parameters van de Lee Carter modellen als

$$
\hat{Y}_{i,t+1}  = \exp{(\hat{\alpha}_{i} + \hat{\beta}_{i} \hat{k}_{t+1})}
$$


## Schattingsmethode

We schatten de Lee Carter modellen als non-lineaire systemen, gebruikmaakend van het gnm-pakket in R [@turner2007generalized]. Zie ook de discussie in @currie2013fitting. De methodes hier gekozen hebben hun beperkingen maar zijn vrij recht-aan-recht toe en kant-en-klare software is beschikbaar.

Omdat de eenheden van de afhankelijke variabelen wat verschillen zijn de Lee Carter modellen gefit onder net wat verschillende aannames: de verhuizing- en woningbouwmodellen worden geschat als Poisson met log link en risiko-bevolking als offset variabel, en de regionale factor modellen worden geschat als Gaussian met log link.


## Voorspellingen
Om $k_{t}$ te kunnen voorspellen maken we gebruik van een univariate exponential smoothing model [@hyndman2002state]. Hier gebruiken we de functie *ets()* in R waarmee het volgende single-source of error state space model wordt geschat

$$
\begin{aligned}
k_{t} &= \theta_{t-1} + e_{t} \\
\theta_{t} &= \theta_{t-1} + \nu e_{t}
\end{aligned}
$$

De schattingsfouten $e_{t}$ zijn normaalverdeeld met variantie $\sigma^{2}$:

$$
e_{t} \sim NID(0, \sigma^{2})
$$

De twee geschatte parameters hier zijn $\nu$ en $\sigma^{2}$. Als $\nu=1$ is dit een random walk. De vergelijking hierboven beschrijvt dus een simpel stochastisch systemen, waarmee we tokoemstige waarden van $k_{t}^{g}$ kunnen simuleren. Een h-stap-vooruit voorspellingen van simulatie $s$ kunnen we schrijven als $\bar{k}_{t+h,s}$. Op basis van de simulaties $s$ kunnen we gemiddelde waarden, $\hat{k}_{t+h}$, en betrouwbaarheidsintervallen berekenen.

# Proefrun met een dummy model

In deze sectie worden resultaten van een proefrun met het model beschreven. Hoofddoel van de exercitie is te analyseren hoe gevoelig de voorgespelde risikobevolking is ten opzichte van onzekerheden in (i) vertrek en (ii) vertrek en woningbouwproductie gecombineerd. De opzet is vergelijkbaar met @hyndman2008stochastic, die een Monte Carlo-simulatie van toekomstige bevolking naar geslacht uitvoeren, door Lee Carter modellen voor vruchtbaarheid, sterfte en netto migratie te combineren met en een cohort componentmethode.

In deze notitie maken we een Monte Carlo analyse van de risikobevolking met 100 simulaties van $k_{t}$ tot 2040. Het genereren van simulaties is vrijwel volledig automatisch en het model schaalt daarom heel makkelijk; op een computer met meer geheugen kunnen we meer dan 100 simulaties draaien zonder dat dat ekstra werk oplevert.

De data gebruikt om de Lee Carter modellen te schatten betreeft tijdsreeksen over verhuizingen, bevolking en woningbouw tussen 1995 en 2018 gebruikt; alles beschikbaar van CBS Open Data. Het gaat over de volgende series: migratie 60048ned, bevolking 70072ned, woningbouw 37713. We gebruiken de leeftijdsgroepen uit de series 60048ned en COROP als regionaal niveau. Ik interpreteer tussengemeentenverhuisde personen als tussenCOROPverhuisde personen binnengemeentenverhuisde personen als binnenCOROPverhuisde personen. Verhuizingen worden gedefinieerd als de som van binnenregionale verhuizingen en vertrek, net als in PEARL.

Voor de tijdsreeksen van $\bar{M}_{i,t}^{g}$ en $W_{i,t}^{g}$ gebruik ik een 3-jaar voortschrijdend gemiddelde, wat betekent dat de tijdsreeks voor de regional factor en voor nieuwbouwwoningen van 1998 tot 2018 loopt. De risikobevolking is berekent als het gemiddelde van de bevolking aan het begin en aan het einde van het jaar.

De kant van vestiging wordt zo simpel mogelijk gehouden; in een volschala run zal vestiging immers worden bepaald met PEARL. In deze notitie bereken ik de vestigingskant $\pi_{i,t}$ in regio $i$ als het aandeel nieuwbouwwoningen van de regio in het totaal aantal nieuwbouwwoningen

$$
\pi_{i,t} = \frac{W_{i,t}}{\sum_{j}W_{j,t}}
$$

Dan kunnen we het model van de vergelijkingen (1) - (4) sluiten met de volgende regel voor dynamische ontwikkeling van de risikobevolking:

\begin{equation}
\tag{5}
P_{i,x,t+1}^{g} = P_{i,x,t}^{g} - M_{i,x,t}^{g} + \sum_{j} M_{j, x, t}^{g} * \pi_{i,t}
\end{equation}


## Simulaties van de tijdstrend

Van de omschrijving boven weten we dat de vector $k_{t}$ 2 geschatte tijstrenden bevat:  regionale factor en woningbouwproductie.  De resultaten van de simulaties zijn te zien in Figuur \@ref(fig:simulations-timetrend). De zwarte lijn in de figuren zijn de $\hat{k}_{t}$ geschat met de Lee Carter modellen en de grijze lijnen zijn h-stappen-vooruit simulaties gemaakt met het tijdsreeks model, $\hat{k}_{t+h}$.

```{r simulations-timetrend, fig.cap = "Simulaties van de tijdstrend"}

tmp_dt <- rbindlist(lapply(seq(1, n_sim),
                           function(x){
                               data.table(run = x,
                                          t = time(sims[[x]]$reg),
                                          regionale_factor = sims[[x]]$reg,
                                          nieuwbouwwoningen = sims[[x]]$woningen
                                          )
                           }))

ggplot(melt(tmp_dt,
            id.vars = c('run', 't')
            )[,
              mean_val := mean(value),
              by = c('t', 'variable')
              ], aes(t, value)) +
    geom_line(aes(group = run), col = 'grey') +
    geom_line(aes(group = run, y = mean_val), lty = 'dotted') +
    geom_line(data = melt(data.table(t = time(y_r),
                                     regionale_factor = as.numeric(y_r),
                                     nieuwbouwwoningen = as.numeric(y_w)
                ),
     id.vars = 't'), aes(y = value), col = 'black') +
    facet_wrap(~variable, scales = 'free', ncol = 2) +
    theme_bw()

```

## Resultaten van het model van vergelijkingen (1) tot (5)

De simulaties van de vorige sectie worden gecombineerd met het migratiemodel in vergelijkingen (1) - (5) om de ontwikkeling van de risikobevolking tot 2040 te simuleren. De omvang van de totale risikobevolking in 4 COROP-regio's. Als voorbeeld kiezen we de vier COROP-regio's met de grote steden. De grijze vlakken in de figuren geven een 80 \% bandbreedte aan en de vaste lijn het gemiddelde van alle simulaties.

Om de relatieve invloed van de verschillende variabelen (regionale factor; nieuwbouwwoningen) op de voorgespelde risikobevolking te ontrafelen kunnen we switches introduceren. Deze swiches verzamelen we in een vector $\gamma = \{ \gamma_{f}, \gamma_{w} \}$ van binaire variabelen. De h-stap-vooruit voorspelling, $\tilde{k}_{t+h,s}$ kunnen we definieren als

$$
\tilde{k}_{t+h,s} = \gamma\hat{k}_{t+h,s} + (1-\gamma)\bar{k}_{t+h}
$$

Van deze vergelijking zien we dat $\gamma_{f} = 0$ bijvoorbeeld betekent dat er met de middenvariant van de regionale factor wordt gewerkt en $\gamma_{f} = 1$ dat we de hele waaier van gesimuleerde waarden van Figuur \@ref(fig:simulations-timetrend) gebruiken.

Figuur \@ref(fig:results-net-migration-time) laat de netto migratie (som over leeftijden) in de vier grote steden zien. In onze nep-model heeft Amsterdam en Utrecht een positieve migratiesaldo en Rotterdam en den Haag een negatieve saldo. Links in het figuur waarin $\gamma_{f} = \gamma_{w} = 0$ wordt voor alle drie variabelen met een middenvariant gewerkt. Niet geheel verrassend is er dan ook geen variatie in de uitkomsten in dit scenario. Het figuur laat zien de variatie niewbouwwoningen ($\gamma_{w}$), gevolgd door de regionale factor ($\gamma_{f}$), de grootste effecten heeft op netto migratie. Aan de rechterkant van het figuur zien ook een bepaalde stapeling van onzekerheid, die ook nog enigszins regionaal verschilt. Het valt op dat het model beweegt richting een evenwicht zonder netto migratie - dit is natuurlijk anders in PEARL.

```{r results-net-migration-time, fig.cap = "Netto migratie (totaal) in s' Gravenhage (518), Amsterdam (363), Utrecht (344) en Rotterdam (599)"}

##reg_sel <- c('CR23  ', 'CR26  ', 'CR17  ', 'CR29  ')
code_names <- c('Rotterdam', 'Amsterdam', 'Utrecht', "'s-Gravenhage")
code_sel <- sapply(code_names,
                   function(x) {
                     tmp <- attributes(pop_dt$RegioS)$labels[names(attributes(pop_dt$RegioS)$labels) == x]
                     return(as.numeric(gsub("GM", "", tmp)))
                   })


ggplot(melt(out[code %in% code_sel,
           sum(net_migration),
           by = c('code', 'run', 'gamma', 'year')
           ],
           id.vars = c('code', 'run', 'year', 'V1')
           )[,
               {
                   ## tmp = quantile(V1)
                   ## list(tmp[2], tmp[3], tmp[4])
                   tmp = quantile(V1, probs = seq(0, 1, by = 0.1))
                   list(tmp[2], tmp[6], tmp[10])
               },
             by = c('code', 'variable', 'value', 'year')
             ],
       aes(year, V2)) +
    geom_ribbon(aes(ymin = V1, ymax = V3), fill = 'grey') +
    geom_line() +
    facet_grid(code~value, scales = 'free') +
    theme_bw() +
    ylab('Netto migratie') +
    scale_x_continuous(breaks = c(2020, 2030, 2040), labels = c(2020, 2030, 2040))

```

Figuur \@ref(fig:results-net-migration-age) geeft de netto migratie per leeftijd aan voor dezelfde vier groote regio's, waardoor verandering door de tijd al inbegrepen in het voorspellingsinterval is. Daarom zien we ook links in het figuur, waar alle $\gamma$ zijn 0, een interval. Maar we zien ook het interval toenemen als we variabelen laten varieren, net zoals in Figuur \@ref(fig:results-net-migration-time).

```{r results-net-migration-age, fig.cap = "Netto migratie in s' Gravenhage (518), Amsterdam (363), Utrecht (344) en Rotterdam (599)"}

ggplot(melt(out[code %in% code_sel,
           net_migration,
           by = c('code', 'leeftijd', 'run', 'gamma', 'year')
           ],
           id.vars = c('code', 'leeftijd', 'run', 'year', 'net_migration')
           )[,
               {
                   ## tmp = quantile(V1)
                   ## list(tmp[2], tmp[3], tmp[4])
                   tmp = quantile(net_migration, probs = seq(0, 1, by = 0.1))
                   list(tmp[2], tmp[6], tmp[10])
               },
             by = c('code', 'variable', 'value', 'leeftijd')
             ],
       aes(leeftijd, V2, group = value)) +
    geom_ribbon(aes(ymin = V1, ymax = V3), fill = 'grey') +
    geom_line() +
    facet_grid(code~value, scales = 'free') +
    theme_bw() +
    theme(axis.text.x = element_text(angle = 90)) +
    ylab('Netto migratie')

```


De ontwikkeling van de (totale) risikobevolking zijn te zien in Figuur \@ref(fig:results-regional). De zwarte lijnen in het figuur is de gemiddelde voorspelling en het grijz gebied om de lijn 80 procent onzekerheidsmarges. Aan de linkerkant in de figuur heeft woningbouw geen invloed op vestiging ($gamma = 0$); hier zien we dat de bevolkingsontwikkeling volledig wordt gedreven door het saldo. Hierdoor zijn de onzekerheidsmarges ook relatief klein.

```{r results-regional, fig.cap = "Risikobevolking (totaal) in s' Gravenhage (518), Amsterdam (363), Utrecht (344) en Rotterdam (599)"}

reg_sel <- c('CR23  ', 'CR26  ', 'CR17  ', 'CR29  ')

ggplot(melt(out[code %in% code_sel,
           sum(risk_pop),
           by = c('code', 'run', 'gamma', 'year')
           ],
           id.vars = c('code', 'run', 'year', 'V1')
           )[,
               {
                   ## tmp = quantile(V1)
                   ## list(tmp[2], tmp[3], tmp[4])
                   tmp = quantile(V1, probs = seq(0, 1, by = 0.1))
                   list(tmp[2], tmp[6], tmp[10])
               },
             by = c('code', 'variable', 'value', 'year')
             ],
       aes(year, V2)) +
    geom_ribbon(aes(ymin = V1, ymax = V3), fill = 'grey') +
    geom_line() +
    facet_grid(code~value, scales = 'free') +
    theme_bw() +
    ylab('Risikobevolking') +
    scale_x_continuous(breaks = c(2020, 2030, 2040), labels = c(2020, 2030, 2040))

```

Figuur \@ref(fig:results-age-groups) laat resultaten per leeftijdsgroep, voor jaren 2020, 2030 en 2040 zien. We zien dezelfde dynamiek terug als in de voorafgaande figuur: te groter invloed van woningbouw op de vestigingskans, te groter de onzekerheidsmarges. We zien ook wat verschuivingen in de leeftijdsverdeling. Ik ga hier niet verder in op de oorzaken daarvan, maar dit is juist interessant om te onderzoeken in een meer diepgaande analyse.

```{r results-age-groups, fig.cap = "Leeftijdsverdeling van de risikobevolking in s' Gravenhage (518), Amsterdam (363), Utrecht (344) en Rotterdam (599)in 2020, 2030 en 2040"}

ggplot(out[code %in% code_sel & year %in% seq(2020, 2040, by = 10),
           sum(risk_pop),
           by = c('code', 'run', 'gamma', 'leeftijd', 'year')
           ][,
               {
                   ## tmp = quantile(V1)
                   ## list(tmp[2], tmp[3], tmp[4])
                   tmp = quantile(V1, probs = seq(0, 1, by = 0.1))
                   list(tmp[2], tmp[6], tmp[10])
               },
             by = c('code', 'gamma', 'leeftijd', 'year')
             ],
       aes(leeftijd, V2, group = factor(year))) +
    geom_ribbon(aes(ymin = V1, ymax = V3, fill = factor(year)), alpha = 0.3) +
    geom_line(aes(col = factor(year))) +
    facet_grid(code~gamma, scales = 'free') +
    scale_colour_brewer(palette = 'Set1', name = 'Jaar') +
    scale_fill_brewer(palette = 'Set1', name = 'Jaar') +
    theme_bw() +
    theme(axis.text.x = element_text(angle = 90)) +
    ylab('Risikobevolking')

```

# Conclusies, opmerkingen en hoe verder

In dit document heb ik een voorstel gemaakt voor en stochastische simulatiemethode geschikt voor PEARL. De groote voordeel van deze methode is de dimensionaliteitsreductie: de test die ik hier heb gegraaid kunnen we vrij eenvoudig opschalen naar leeftijden en gemeenten in plaats van leeftijdsgroepen, gemeenten in plaats van COROP-regio's en meer simulaties. Zover ik weet is het Lee Carter model nooit toegepast op regionale prognoses, in dat opzicht is dit ook nieuw.

De resultaten hier suggereren dat de meeste variatie in netto migratie en risikobevolking kwam door variatie in de regionale factor en in nieuwbouwwoningen, terwijl variatie in de leeftijdsspecifieke verhuizingen weinig effect had. Dit heeft gedeeltelijk te maken met het feit dat de variatie in verhuizingen voor leeftijden met een hoge verhuiskans vrij laag was (zie Figuren \@(fig:simulations-age-groups2) en \@(fig:simulations-age-groups3) in de Appendix). Een optie is om het Lee Carter model voor verhuizingen net wat anders te schatten of direct te werken met de verhuiskans. Een ander optie is om nationale leeftijdsspecifieke verhuizingen of verhuiskans weg te laten van deze analyse.

Dit document moet worden gezien als stap naar een 'proof-of-concept'. De resultaten in de vorige sectie laten met name zien hoe het zou kunnen werken in de context van PEARL, maar door de aannames zijn de resultaten ook niet erg realistisch. De geschatte Lee Carter modellen zouden we beter naar moeten kijken. Er zijn een aantal andere schattingsmethode's die wellicht nauwkeuriger zijn dan die die ik hier heb gebruikt. Bijvoorbeeld Structural Value Decomposition is een andere bekende optie hiervoor [@stoeldraijer2013impact].

Een uitdaging met de Monte Carlo method zoals hier voorgesteld is dat de bandbreedtes mogelijk erg groot kunnen worden [@renshaw2008simulation]. Een optie is om een meer gerichte Monte Carlo, waarin stochastische simulaties worden gecombineerd met expert judgment. Hierbij een suggestie van de PBL-thuisexpert Andries: "Trek voor een bepaalde regio een bepaalde waarde uit de verdeling van de regionale factor (en hou voor de andere regio’s de regionale factor gelijk aan de prognose) en trek voor de omliggende gemeenten (van die specifieke regio) uit de verdeling van de  woningbouw. Deze waarden kun je dan in PEARL stoppen. Per regio zou je dit volgens de principes van Monte Carlo modelering een flink aantal keren moeten doen, bv. 50 keer. Dit betekent dat je dan - in de cloud - PEARL het aantal regio’s (in principe alle gemeenten) * 50 keer moeten runnen (uitgaande van b.v. 400 gemeenten dus rond 20 duizend runs)."



# Appendix


```{r descriptive-plots2, fig.cap = "De regionale factor", cache = T}

ggplot(inp_dt[!is.na(regional_factor)],
       aes(year, regional_factor, group = code)) +
  ##geom_line(aes(col = code)) +
  geom_line(alpha = 0.4) +
    facet_wrap(~geslacht) +
    theme_bw()


```

```{r descriptive-plots3, fig.cap = "Nieuwbouwwoningen (landelijk)", cache = T}

ggplot(woon_dt[RegioS == 'NL01  '], aes(year, Nieuwbouwwoningen_91)) +
    geom_line() +
    theme_bw()

```


```{r plot-results-regio1 ,fig.cap = "Parameters van het regiomodel", cache = T}

## settings for the alpha parameters in the
alpha_params <- paste0("as.factor(code)", unique(inp_dt$code))
alpha_idx <- match(alpha_params, names(coefficients(LC.gaussian.reg)))
alpha_idx <- alpha_idx[!is.na(alpha_idx)]
alpha_reg <- as.numeric(gsub("as.factor\\(code\\)", "",
                  names(coefficients(LC.gaussian.reg)[alpha_idx])
                  ))
alpha_v_idx <- match("as.factor(geslacht)vrouwen",
                     names(coefficients(LC.gaussian.reg)
                           )
                     )

## alpha
p1 <- ggplot(rbind(data.table(reg = alpha_reg,
                              pop = inp_dt[year == 2017 & leeftijd == 'Totaal' & geslacht == 'mannen' & code %in% alpha_reg, risk_pop],
                              a = as.numeric(coefficients(LC.gaussian.reg)[alpha_idx]),
                              geslacht = 'mannen'
                              ),
                              data.table(reg = alpha_reg,
                                         pop = inp_dt[year == 2017 & leeftijd == 'Totaal' & geslacht == 'vrouwen' & code %in% alpha_reg, risk_pop],
                              a = as.numeric(coefficients(LC.gaussian.reg)[alpha_v_idx]) + as.numeric(coefficients(LC.gaussian.reg)[alpha_idx]),
                              geslacht = 'vrouwen'
                              )), aes(log(pop), a)) +
  geom_point(aes(col = geslacht)) +
  geom_smooth(aes(col = geslacht)) +
  theme_bw()

## beta
beta_params <- paste0("Mult(., as.factor(year)).as.factor(code)",
                      unique(inp_dt$code)
                      )
beta_idx <- match(beta_params, names(coefficients(LC.gaussian.reg)))
beta_idx <- beta_idx[!is.na(beta_idx)]
beta_reg <- as.numeric(gsub("Mult\\(., as.factor\\(year\\)\\).as.factor\\(code\\)",
                            "",
                  names(coefficients(LC.gaussian.reg)[beta_idx])
                  ))


p2 <- ggplot(data.table(reg = beta_reg,
                        pop = inp_dt[year == 2017 & leeftijd == 'Totaal', sum(risk_pop), by = code][code %in% beta_reg, V1],
                        b = as.numeric(coefficients(LC.gaussian.reg)[beta_idx])), aes(log(pop), b)) +
  geom_point() +
  geom_smooth() +
  theme_bw()

grid.arrange(p1, p2)

```




```{r plot-results-woning1 ,fig.cap = "Parameters van het woningmodel", cache = T}

alpha_idx <- match(alpha_params, names(coefficients(LC.poisson.h)))
alpha_idx <- alpha_idx[!is.na(alpha_idx)]
alpha_reg <- as.numeric(gsub("as.factor\\(code\\)", "",
                  names(coefficients(LC.poisson.h)[alpha_idx])
                  ))
beta_idx <- match(beta_params, names(coefficients(LC.poisson.h)))
beta_idx <- beta_idx[!is.na(beta_idx)]
beta_reg <- as.numeric(gsub("Mult\\(., as.factor\\(year\\)\\).as.factor\\(code\\)",
                            "",
                  names(coefficients(LC.poisson.h)[beta_idx])
                  ))

data.table(alpha_reg,
      inp_dt[year == 2017 & leeftijd == 'Totaal', sum(risk_pop), by = code][code %in% alpha_reg, .(code, V1)]
      )

## alpha
p1 <- ggplot(data.table(reg = alpha_reg,
                        pop = inp_dt[year == 2017 & leeftijd == 'Totaal',
                                     sum(risk_pop),
                                     by = code][code %in% alpha_reg, V1],
                        a = as.numeric(coefficients(LC.poisson.h)[alpha_idx])
                        ),  aes(log(pop), a)) +
  geom_line() +
  geom_smooth() +
  theme_bw()

## beta
p2 <- ggplot(data.table(reg = beta_reg,
                        pop = inp_dt[year == 2017 & leeftijd == 'Totaal',
                                     sum(risk_pop),
                                     by = code][code %in% beta_reg, V1],
                        b = as.numeric(coefficients(LC.poisson.h)[beta_idx])
                        ),  aes(log(pop), b)) +
  geom_line() +
  geom_smooth() +
  theme_bw()

grid.arrange(p1, p2)

```

<!-- ```{r plot-results-woning2 ,fig.cap = "Modellenfit woning", cache = T} -->

<!-- ggplot(data.table(LC.poisson.pred.h$data, yhat = fitted(LC.poisson.pred.h)), -->
<!--        aes(year, Nieuwbouwwoningen_91)) + -->
<!--     geom_line(col = 'grey') + -->
<!--     geom_line(aes(y=yhat)) + -->
<!--     facet_wrap(~RegioS) + -->
<!--     theme_bw() -->

<!-- ``` -->

```{r simulations-region3, fig.cap = "Simulaties regionale factor", cache = T}

ggplot(sim_regio[code %in% code_sel], aes(year, regional_factor_k)) +
    geom_line(aes(group = run), col = 'grey', alpha = 0.4) +
    geom_line(aes(group = run, y = regional_factor_mean), lty = 'dotted') +
    geom_line(data = inp_dt[code %in% code_sel & !is.na(regional_factor)], aes(y = regional_factor))  +
    facet_wrap(code ~ geslacht) +
    theme_bw()

```

```{r simulations-dwellings, fig.cap = "Simulaties woningbouw", cache = T}


ggplot(sim_woning[code %in% code_sel], aes(year, nieuwbouw_k)) +
    geom_line(aes(group = run), col = 'grey', alpha = 0.4) +
    geom_line(aes(group = run, y = nieuwbouw_mean), lty = 'dotted') +
    geom_line(data = inp_wn_dt[code %in% code_sel & !is.na(nieuwbouwwoningen_rmean)], aes(y = nieuwbouwwoningen_rmean))  +
    facet_wrap(~code) +
    theme_bw() +
    ggtitle('Woningen')

```

# Literatuur
